{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useRef, useState, useCallback } from 'react';\n\n// Détecte le bon format audio selon le navigateur/OS\nconst getSupportedMimeType = () => {\n  const types = ['audio/webm;codecs=opus', 'audio/webm', 'audio/ogg;codecs=opus', 'audio/ogg', 'audio/mp4', ''];\n  return types.find(t => !t || MediaRecorder.isTypeSupported(t)) || '';\n};\nexport const useVoiceMessage = () => {\n  _s();\n  const [isRecording, setIsRecording] = useState(false);\n  const [audioBlob, setAudioBlob] = useState(null);\n  const [audioUrl, setAudioUrl] = useState(null);\n  const [duration, setDuration] = useState(0);\n  const mediaRecorderRef = useRef(null);\n  const chunksRef = useRef([]);\n  const timerRef = useRef(null);\n  const startTimeRef = useRef(null);\n  const startRecording = useCallback(async () => {\n    try {\n      // Contraintes compatibles mobile\n      const stream = await navigator.mediaDevices.getUserMedia({\n        audio: {\n          echoCancellation: true,\n          noiseSuppression: true,\n          sampleRate: 44100\n        }\n      });\n      const mimeType = getSupportedMimeType();\n      const options = mimeType ? {\n        mimeType\n      } : {};\n      let recorder;\n      try {\n        recorder = new MediaRecorder(stream, options);\n      } catch {\n        recorder = new MediaRecorder(stream); // fallback sans options\n      }\n      chunksRef.current = [];\n      recorder.ondataavailable = e => {\n        if (e.data && e.data.size > 0) {\n          chunksRef.current.push(e.data);\n        }\n      };\n      recorder.onstop = () => {\n        // Calcule la durée réelle\n        const elapsed = Math.round((Date.now() - startTimeRef.current) / 1000);\n        setDuration(elapsed);\n        const mType = recorder.mimeType || 'audio/webm';\n        const blob = new Blob(chunksRef.current, {\n          type: mType\n        });\n\n        // Fix durée 0s : crée un blob avec durée correcte via FileReader\n        fixBlobDuration(blob).then(fixedBlob => {\n          const url = URL.createObjectURL(fixedBlob);\n          setAudioBlob(fixedBlob);\n          setAudioUrl(url);\n        });\n        stream.getTracks().forEach(t => t.stop());\n      };\n      recorder.start(100);\n      mediaRecorderRef.current = recorder;\n      startTimeRef.current = Date.now();\n      setIsRecording(true);\n      setDuration(0);\n      setAudioBlob(null);\n      setAudioUrl(null);\n      timerRef.current = setInterval(() => setDuration(Math.round((Date.now() - startTimeRef.current) / 1000)), 1000);\n    } catch (err) {\n      console.error('Erreur microphone:', err);\n      if (err.name === 'NotAllowedError') {\n        alert('❌ Accès au microphone refusé.\\n\\nSur mobile, le site doit être en HTTPS.\\nUtilise l\\'URL ngrok fournie.');\n      } else if (err.name === 'NotFoundError') {\n        alert('❌ Aucun microphone détecté.');\n      } else {\n        alert(`❌ Erreur microphone : ${err.message}`);\n      }\n    }\n  }, []);\n\n  // Fix bug durée 0s sur Chrome/mobile\n  const fixBlobDuration = blob => {\n    return new Promise(resolve => {\n      const audio = new Audio();\n      audio.src = URL.createObjectURL(blob);\n      audio.addEventListener('loadedmetadata', () => {\n        if (audio.duration === Infinity || isNaN(audio.duration)) {\n          // Force le navigateur à calculer la durée\n          audio.currentTime = 1e101;\n          audio.addEventListener('timeupdate', function handler() {\n            this.removeEventListener('timeupdate', handler);\n            URL.revokeObjectURL(audio.src);\n            resolve(blob); // retourne le blob original\n          });\n        } else {\n          URL.revokeObjectURL(audio.src);\n          resolve(blob);\n        }\n      });\n    });\n  };\n  const stopRecording = useCallback(() => {\n    var _mediaRecorderRef$cur;\n    if (((_mediaRecorderRef$cur = mediaRecorderRef.current) === null || _mediaRecorderRef$cur === void 0 ? void 0 : _mediaRecorderRef$cur.state) === 'recording') {\n      mediaRecorderRef.current.stop();\n    }\n    clearInterval(timerRef.current);\n    setIsRecording(false);\n  }, []);\n  const cancelRecording = useCallback(() => {\n    var _mediaRecorderRef$cur2;\n    if (((_mediaRecorderRef$cur2 = mediaRecorderRef.current) === null || _mediaRecorderRef$cur2 === void 0 ? void 0 : _mediaRecorderRef$cur2.state) === 'recording') {\n      mediaRecorderRef.current.stop();\n    }\n    chunksRef.current = [];\n    clearInterval(timerRef.current);\n    setIsRecording(false);\n    setAudioBlob(null);\n    setAudioUrl(null);\n    setDuration(0);\n  }, []);\n  const resetAudio = useCallback(() => {\n    setAudioBlob(null);\n    setAudioUrl(null);\n    setDuration(0);\n  }, []);\n  const formatDuration = s => {\n    const m = Math.floor(s / 60).toString().padStart(2, '0');\n    const sec = (s % 60).toString().padStart(2, '0');\n    return `${m}:${sec}`;\n  };\n  return {\n    isRecording,\n    audioBlob,\n    audioUrl,\n    duration,\n    startRecording,\n    stopRecording,\n    cancelRecording,\n    resetAudio,\n    formatDuration\n  };\n};\n_s(useVoiceMessage, \"ogByjzxNpbDuSYW27SUTGlKvrCA=\");","map":{"version":3,"names":["useRef","useState","useCallback","getSupportedMimeType","types","find","t","MediaRecorder","isTypeSupported","useVoiceMessage","_s","isRecording","setIsRecording","audioBlob","setAudioBlob","audioUrl","setAudioUrl","duration","setDuration","mediaRecorderRef","chunksRef","timerRef","startTimeRef","startRecording","stream","navigator","mediaDevices","getUserMedia","audio","echoCancellation","noiseSuppression","sampleRate","mimeType","options","recorder","current","ondataavailable","e","data","size","push","onstop","elapsed","Math","round","Date","now","mType","blob","Blob","type","fixBlobDuration","then","fixedBlob","url","URL","createObjectURL","getTracks","forEach","stop","start","setInterval","err","console","error","name","alert","message","Promise","resolve","Audio","src","addEventListener","Infinity","isNaN","currentTime","handler","removeEventListener","revokeObjectURL","stopRecording","_mediaRecorderRef$cur","state","clearInterval","cancelRecording","_mediaRecorderRef$cur2","resetAudio","formatDuration","s","m","floor","toString","padStart","sec"],"sources":["/home/voaybe/Documents/projet/real-time-chat-app/client/src/hooks/useVoiceMessage.js"],"sourcesContent":["import { useRef, useState, useCallback } from 'react';\n\n// Détecte le bon format audio selon le navigateur/OS\nconst getSupportedMimeType = () => {\n  const types = [\n    'audio/webm;codecs=opus',\n    'audio/webm',\n    'audio/ogg;codecs=opus',\n    'audio/ogg',\n    'audio/mp4',\n    '',\n  ];\n  return types.find((t) => !t || MediaRecorder.isTypeSupported(t)) || '';\n};\n\nexport const useVoiceMessage = () => {\n  const [isRecording,  setIsRecording]  = useState(false);\n  const [audioBlob,    setAudioBlob]    = useState(null);\n  const [audioUrl,     setAudioUrl]     = useState(null);\n  const [duration,     setDuration]     = useState(0);\n\n  const mediaRecorderRef = useRef(null);\n  const chunksRef        = useRef([]);\n  const timerRef         = useRef(null);\n  const startTimeRef     = useRef(null);\n\n  const startRecording = useCallback(async () => {\n    try {\n      // Contraintes compatibles mobile\n      const stream = await navigator.mediaDevices.getUserMedia({\n        audio: {\n          echoCancellation: true,\n          noiseSuppression: true,\n          sampleRate: 44100,\n        }\n      });\n\n      const mimeType = getSupportedMimeType();\n      const options = mimeType ? { mimeType } : {};\n\n      let recorder;\n      try {\n        recorder = new MediaRecorder(stream, options);\n      } catch {\n        recorder = new MediaRecorder(stream); // fallback sans options\n      }\n\n      chunksRef.current = [];\n\n      recorder.ondataavailable = (e) => {\n        if (e.data && e.data.size > 0) {\n          chunksRef.current.push(e.data);\n        }\n      };\n\n      recorder.onstop = () => {\n        // Calcule la durée réelle\n        const elapsed = Math.round((Date.now() - startTimeRef.current) / 1000);\n        setDuration(elapsed);\n\n        const mType = recorder.mimeType || 'audio/webm';\n        const blob = new Blob(chunksRef.current, { type: mType });\n\n        // Fix durée 0s : crée un blob avec durée correcte via FileReader\n        fixBlobDuration(blob).then((fixedBlob) => {\n          const url = URL.createObjectURL(fixedBlob);\n          setAudioBlob(fixedBlob);\n          setAudioUrl(url);\n        });\n\n        stream.getTracks().forEach((t) => t.stop());\n      };\n\n      recorder.start(100);\n      mediaRecorderRef.current = recorder;\n      startTimeRef.current = Date.now();\n      setIsRecording(true);\n      setDuration(0);\n      setAudioBlob(null);\n      setAudioUrl(null);\n\n      timerRef.current = setInterval(\n        () => setDuration(Math.round((Date.now() - startTimeRef.current) / 1000)),\n        1000\n      );\n    } catch (err) {\n      console.error('Erreur microphone:', err);\n      if (err.name === 'NotAllowedError') {\n        alert('❌ Accès au microphone refusé.\\n\\nSur mobile, le site doit être en HTTPS.\\nUtilise l\\'URL ngrok fournie.');\n      } else if (err.name === 'NotFoundError') {\n        alert('❌ Aucun microphone détecté.');\n      } else {\n        alert(`❌ Erreur microphone : ${err.message}`);\n      }\n    }\n  }, []);\n\n  // Fix bug durée 0s sur Chrome/mobile\n  const fixBlobDuration = (blob) => {\n    return new Promise((resolve) => {\n      const audio = new Audio();\n      audio.src = URL.createObjectURL(blob);\n      audio.addEventListener('loadedmetadata', () => {\n        if (audio.duration === Infinity || isNaN(audio.duration)) {\n          // Force le navigateur à calculer la durée\n          audio.currentTime = 1e101;\n          audio.addEventListener('timeupdate', function handler() {\n            this.removeEventListener('timeupdate', handler);\n            URL.revokeObjectURL(audio.src);\n            resolve(blob); // retourne le blob original\n          });\n        } else {\n          URL.revokeObjectURL(audio.src);\n          resolve(blob);\n        }\n      });\n    });\n  };\n\n  const stopRecording = useCallback(() => {\n    if (mediaRecorderRef.current?.state === 'recording') {\n      mediaRecorderRef.current.stop();\n    }\n    clearInterval(timerRef.current);\n    setIsRecording(false);\n  }, []);\n\n  const cancelRecording = useCallback(() => {\n    if (mediaRecorderRef.current?.state === 'recording') {\n      mediaRecorderRef.current.stop();\n    }\n    chunksRef.current = [];\n    clearInterval(timerRef.current);\n    setIsRecording(false);\n    setAudioBlob(null);\n    setAudioUrl(null);\n    setDuration(0);\n  }, []);\n\n  const resetAudio = useCallback(() => {\n    setAudioBlob(null);\n    setAudioUrl(null);\n    setDuration(0);\n  }, []);\n\n  const formatDuration = (s) => {\n    const m = Math.floor(s / 60).toString().padStart(2, '0');\n    const sec = (s % 60).toString().padStart(2, '0');\n    return `${m}:${sec}`;\n  };\n\n  return {\n    isRecording, audioBlob, audioUrl, duration,\n    startRecording, stopRecording, cancelRecording, resetAudio, formatDuration,\n  };\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}