{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useRef, useState, useCallback } from 'react';\nexport const useVoiceMessage = () => {\n  _s();\n  const [isRecording, setIsRecording] = useState(false);\n  const [audioBlob, setAudioBlob] = useState(null);\n  const [audioUrl, setAudioUrl] = useState(null);\n  const [duration, setDuration] = useState(0);\n  const mediaRecorderRef = useRef(null);\n  const chunksRef = useRef([]);\n  const timerRef = useRef(null);\n  const startRecording = useCallback(async () => {\n    try {\n      const stream = await navigator.mediaDevices.getUserMedia({\n        audio: true\n      });\n      const recorder = new MediaRecorder(stream, {\n        mimeType: 'audio/webm'\n      });\n      chunksRef.current = [];\n      recorder.ondataavailable = e => {\n        if (e.data.size > 0) chunksRef.current.push(e.data);\n      };\n      recorder.onstop = () => {\n        const blob = new Blob(chunksRef.current, {\n          type: 'audio/webm'\n        });\n        const url = URL.createObjectURL(blob);\n        setAudioBlob(blob);\n        setAudioUrl(url);\n        stream.getTracks().forEach(t => t.stop());\n      };\n      recorder.start(100); // collect data every 100ms\n      mediaRecorderRef.current = recorder;\n      setIsRecording(true);\n      setDuration(0);\n      timerRef.current = setInterval(() => setDuration(d => d + 1), 1000);\n    } catch (err) {\n      console.error('Erreur microphone:', err);\n      alert('Impossible d\\'accéder au microphone');\n    }\n  }, []);\n  const stopRecording = useCallback(() => {\n    var _mediaRecorderRef$cur;\n    (_mediaRecorderRef$cur = mediaRecorderRef.current) === null || _mediaRecorderRef$cur === void 0 ? void 0 : _mediaRecorderRef$cur.stop();\n    setIsRecording(false);\n    clearInterval(timerRef.current);\n  }, []);\n  const cancelRecording = useCallback(() => {\n    var _mediaRecorderRef$cur2;\n    if (((_mediaRecorderRef$cur2 = mediaRecorderRef.current) === null || _mediaRecorderRef$cur2 === void 0 ? void 0 : _mediaRecorderRef$cur2.state) === 'recording') {\n      mediaRecorderRef.current.stop();\n    }\n    chunksRef.current = [];\n    setIsRecording(false);\n    setAudioBlob(null);\n    setAudioUrl(null);\n    setDuration(0);\n    clearInterval(timerRef.current);\n  }, []);\n  const resetAudio = useCallback(() => {\n    setAudioBlob(null);\n    setAudioUrl(null);\n    setDuration(0);\n  }, []);\n  const formatDuration = seconds => {\n    const m = Math.floor(seconds / 60).toString().padStart(2, '0');\n    const s = (seconds % 60).toString().padStart(2, '0');\n    return `${m}:${s}`;\n  };\n  return {\n    isRecording,\n    audioBlob,\n    audioUrl,\n    duration,\n    startRecording,\n    stopRecording,\n    cancelRecording,\n    resetAudio,\n    formatDuration\n  };\n};\n_s(useVoiceMessage, \"hHczXu/8brpdjZMdkenvqdklOWg=\");","map":{"version":3,"names":["useRef","useState","useCallback","useVoiceMessage","_s","isRecording","setIsRecording","audioBlob","setAudioBlob","audioUrl","setAudioUrl","duration","setDuration","mediaRecorderRef","chunksRef","timerRef","startRecording","stream","navigator","mediaDevices","getUserMedia","audio","recorder","MediaRecorder","mimeType","current","ondataavailable","e","data","size","push","onstop","blob","Blob","type","url","URL","createObjectURL","getTracks","forEach","t","stop","start","setInterval","d","err","console","error","alert","stopRecording","_mediaRecorderRef$cur","clearInterval","cancelRecording","_mediaRecorderRef$cur2","state","resetAudio","formatDuration","seconds","m","Math","floor","toString","padStart","s"],"sources":["/home/voaybe/Documents/projet/real-time-chat-app/client/src/hooks/useVoiceMessage.js"],"sourcesContent":["import { useRef, useState, useCallback } from 'react';\n\nexport const useVoiceMessage = () => {\n  const [isRecording,  setIsRecording]  = useState(false);\n  const [audioBlob,    setAudioBlob]    = useState(null);\n  const [audioUrl,     setAudioUrl]     = useState(null);\n  const [duration,     setDuration]     = useState(0);\n  const mediaRecorderRef = useRef(null);\n  const chunksRef        = useRef([]);\n  const timerRef         = useRef(null);\n\n  const startRecording = useCallback(async () => {\n    try {\n      const stream = await navigator.mediaDevices.getUserMedia({ audio: true });\n      const recorder = new MediaRecorder(stream, { mimeType: 'audio/webm' });\n      chunksRef.current = [];\n\n      recorder.ondataavailable = (e) => {\n        if (e.data.size > 0) chunksRef.current.push(e.data);\n      };\n\n      recorder.onstop = () => {\n        const blob = new Blob(chunksRef.current, { type: 'audio/webm' });\n        const url  = URL.createObjectURL(blob);\n        setAudioBlob(blob);\n        setAudioUrl(url);\n        stream.getTracks().forEach((t) => t.stop());\n      };\n\n      recorder.start(100); // collect data every 100ms\n      mediaRecorderRef.current = recorder;\n      setIsRecording(true);\n      setDuration(0);\n\n      timerRef.current = setInterval(() => setDuration((d) => d + 1), 1000);\n    } catch (err) {\n      console.error('Erreur microphone:', err);\n      alert('Impossible d\\'accéder au microphone');\n    }\n  }, []);\n\n  const stopRecording = useCallback(() => {\n    mediaRecorderRef.current?.stop();\n    setIsRecording(false);\n    clearInterval(timerRef.current);\n  }, []);\n\n  const cancelRecording = useCallback(() => {\n    if (mediaRecorderRef.current?.state === 'recording') {\n      mediaRecorderRef.current.stop();\n    }\n    chunksRef.current = [];\n    setIsRecording(false);\n    setAudioBlob(null);\n    setAudioUrl(null);\n    setDuration(0);\n    clearInterval(timerRef.current);\n  }, []);\n\n  const resetAudio = useCallback(() => {\n    setAudioBlob(null);\n    setAudioUrl(null);\n    setDuration(0);\n  }, []);\n\n  const formatDuration = (seconds) => {\n    const m = Math.floor(seconds / 60).toString().padStart(2, '0');\n    const s = (seconds % 60).toString().padStart(2, '0');\n    return `${m}:${s}`;\n  };\n\n  return {\n    isRecording, audioBlob, audioUrl, duration,\n    startRecording, stopRecording, cancelRecording, resetAudio,\n    formatDuration,\n  };\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}