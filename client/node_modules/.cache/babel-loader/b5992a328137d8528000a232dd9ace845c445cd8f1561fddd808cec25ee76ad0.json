{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useRef, useState, useCallback, useEffect } from 'react';\nconst ICE_SERVERS = {\n  iceServers: [{\n    urls: 'stun:stun.l.google.com:19302'\n  }, {\n    urls: 'stun:stun1.l.google.com:19302'\n  }, {\n    urls: 'stun:stun2.l.google.com:19302'\n  }]\n};\nexport const useWebRTC = socket => {\n  _s();\n  const [localStream, setLocalStream] = useState(null);\n  const [remoteStream, setRemoteStream] = useState(null);\n  const [callStatus, setCallStatus] = useState('idle');\n  // 'idle' | 'calling' | 'receiving' | 'in-call'\n  const [callType, setCallType] = useState(null); // 'audio' | 'video'\n  const [callerId, setCallerId] = useState(null);\n  const [targetId, setTargetId] = useState(null);\n  const pcRef = useRef(null);\n\n  // Nettoyer la connexion\n  const cleanupPC = useCallback(() => {\n    if (pcRef.current) {\n      pcRef.current.ontrack = null;\n      pcRef.current.onicecandidate = null;\n      pcRef.current.close();\n      pcRef.current = null;\n    }\n  }, []);\n\n  // Obtenir le stream local\n  const getLocalStream = useCallback(async type => {\n    try {\n      const stream = await navigator.mediaDevices.getUserMedia({\n        audio: true,\n        video: type === 'video'\n      });\n      setLocalStream(stream);\n      return stream;\n    } catch (err) {\n      console.error('Erreur accès médias:', err);\n      throw err;\n    }\n  }, []);\n\n  // Créer la RTCPeerConnection\n  const createPeerConnection = useCallback((stream, remoteTargetId) => {\n    cleanupPC();\n    const pc = new RTCPeerConnection(ICE_SERVERS);\n\n    // Ajouter les tracks locaux\n    stream.getTracks().forEach(track => pc.addTrack(track, stream));\n\n    // Préparer le stream distant\n    const remoteMediaStream = new MediaStream();\n    setRemoteStream(remoteMediaStream);\n    pc.ontrack = e => {\n      e.streams[0].getTracks().forEach(track => {\n        remoteMediaStream.addTrack(track);\n      });\n    };\n    pc.onicecandidate = e => {\n      if (e.candidate && remoteTargetId) {\n        socket === null || socket === void 0 ? void 0 : socket.emit('call:ice-candidate', {\n          targetId: remoteTargetId,\n          candidate: e.candidate\n        });\n      }\n    };\n    pc.onconnectionstatechange = () => {\n      if (['disconnected', 'failed', 'closed'].includes(pc.connectionState)) {\n        endCall();\n      }\n    };\n    pcRef.current = pc;\n    return pc;\n  }, [socket, cleanupPC]);\n\n  // ── INITIER UN APPEL ──────────────────────────────────────────────────────\n  const startCall = useCallback(async (receiverId, type = 'audio') => {\n    try {\n      setCallType(type);\n      setTargetId(receiverId);\n      setCallStatus('calling');\n      const stream = await getLocalStream(type);\n      const pc = createPeerConnection(stream, receiverId);\n      const offer = await pc.createOffer();\n      await pc.setLocalDescription(offer);\n      socket === null || socket === void 0 ? void 0 : socket.emit('call:initiate', {\n        receiverId,\n        callType: type,\n        offer\n      });\n    } catch (err) {\n      console.error('Erreur démarrage appel:', err);\n      setCallStatus('idle');\n    }\n  }, [socket, getLocalStream, createPeerConnection]);\n\n  // ── RÉPONDRE À UN APPEL ───────────────────────────────────────────────────\n  const answerCall = useCallback(async (incomingCallerId, offer, type = 'audio') => {\n    try {\n      setCallStatus('in-call');\n      setTargetId(incomingCallerId);\n      const stream = await getLocalStream(type);\n      const pc = createPeerConnection(stream, incomingCallerId);\n      await pc.setRemoteDescription(new RTCSessionDescription(offer));\n      const answer = await pc.createAnswer();\n      await pc.setLocalDescription(answer);\n      socket === null || socket === void 0 ? void 0 : socket.emit('call:answer', {\n        callerId: incomingCallerId,\n        answer\n      });\n    } catch (err) {\n      console.error('Erreur réponse appel:', err);\n      setCallStatus('idle');\n    }\n  }, [socket, getLocalStream, createPeerConnection]);\n\n  // ── GÉRER LA RÉPONSE (côté appelant) ─────────────────────────────────────\n  const handleCallAnswered = useCallback(async ({\n    answer\n  }) => {\n    try {\n      var _pcRef$current;\n      await ((_pcRef$current = pcRef.current) === null || _pcRef$current === void 0 ? void 0 : _pcRef$current.setRemoteDescription(new RTCSessionDescription(answer)));\n      setCallStatus('in-call');\n    } catch (err) {\n      console.error('Erreur set remote description:', err);\n    }\n  }, []);\n\n  // ── AJOUTER UN CANDIDAT ICE ───────────────────────────────────────────────\n  const handleICECandidate = useCallback(async ({\n    candidate\n  }) => {\n    try {\n      var _pcRef$current2;\n      await ((_pcRef$current2 = pcRef.current) === null || _pcRef$current2 === void 0 ? void 0 : _pcRef$current2.addIceCandidate(new RTCIceCandidate(candidate)));\n    } catch (err) {\n      console.error('Erreur ajout ICE candidate:', err);\n    }\n  }, []);\n\n  // ── REFUSER UN APPEL ──────────────────────────────────────────────────────\n  const rejectCall = useCallback(incomingCallerId => {\n    socket === null || socket === void 0 ? void 0 : socket.emit('call:reject', {\n      callerId: incomingCallerId\n    });\n    setCallStatus('idle');\n    setCallerId(null);\n  }, [socket]);\n\n  // ── TERMINER L'APPEL ──────────────────────────────────────────────────────\n  const endCall = useCallback((remoteTargetId = null) => {\n    const target = remoteTargetId || targetId;\n    if (target) socket === null || socket === void 0 ? void 0 : socket.emit('call:end', {\n      targetId: target\n    });\n    cleanupPC();\n    localStream === null || localStream === void 0 ? void 0 : localStream.getTracks().forEach(t => t.stop());\n    setLocalStream(null);\n    setRemoteStream(null);\n    setCallStatus('idle');\n    setCallType(null);\n    setCallerId(null);\n    setTargetId(null);\n  }, [socket, targetId, localStream, cleanupPC]);\n\n  // ── TOGGLE MICRO/CAMÉRA ───────────────────────────────────────────────────\n  const toggleMic = useCallback(() => {\n    localStream === null || localStream === void 0 ? void 0 : localStream.getAudioTracks().forEach(t => {\n      t.enabled = !t.enabled;\n    });\n  }, [localStream]);\n  const toggleCamera = useCallback(() => {\n    localStream === null || localStream === void 0 ? void 0 : localStream.getVideoTracks().forEach(t => {\n      t.enabled = !t.enabled;\n    });\n  }, [localStream]);\n  return {\n    localStream,\n    remoteStream,\n    callStatus,\n    callType,\n    callerId,\n    targetId,\n    setCallStatus,\n    setCallType,\n    setCallerId,\n    startCall,\n    answerCall,\n    rejectCall,\n    endCall,\n    handleCallAnswered,\n    handleICECandidate,\n    toggleMic,\n    toggleCamera\n  };\n};\n_s(useWebRTC, \"sOEFNVEkx4buPxJovPizdh0fTnQ=\");","map":{"version":3,"names":["useRef","useState","useCallback","useEffect","ICE_SERVERS","iceServers","urls","useWebRTC","socket","_s","localStream","setLocalStream","remoteStream","setRemoteStream","callStatus","setCallStatus","callType","setCallType","callerId","setCallerId","targetId","setTargetId","pcRef","cleanupPC","current","ontrack","onicecandidate","close","getLocalStream","type","stream","navigator","mediaDevices","getUserMedia","audio","video","err","console","error","createPeerConnection","remoteTargetId","pc","RTCPeerConnection","getTracks","forEach","track","addTrack","remoteMediaStream","MediaStream","e","streams","candidate","emit","onconnectionstatechange","includes","connectionState","endCall","startCall","receiverId","offer","createOffer","setLocalDescription","answerCall","incomingCallerId","setRemoteDescription","RTCSessionDescription","answer","createAnswer","handleCallAnswered","_pcRef$current","handleICECandidate","_pcRef$current2","addIceCandidate","RTCIceCandidate","rejectCall","target","t","stop","toggleMic","getAudioTracks","enabled","toggleCamera","getVideoTracks"],"sources":["/home/voaybe/Documents/projet/real-time-chat-app/client/src/hooks/useWebRTC.js"],"sourcesContent":["import { useRef, useState, useCallback, useEffect } from 'react';\n\nconst ICE_SERVERS = {\n  iceServers: [\n    { urls: 'stun:stun.l.google.com:19302' },\n    { urls: 'stun:stun1.l.google.com:19302' },\n    { urls: 'stun:stun2.l.google.com:19302' },\n  ],\n};\n\nexport const useWebRTC = (socket) => {\n  const [localStream,  setLocalStream]  = useState(null);\n  const [remoteStream, setRemoteStream] = useState(null);\n  const [callStatus,   setCallStatus]   = useState('idle');\n  // 'idle' | 'calling' | 'receiving' | 'in-call'\n  const [callType,  setCallType]  = useState(null); // 'audio' | 'video'\n  const [callerId,  setCallerId]  = useState(null);\n  const [targetId,  setTargetId]  = useState(null);\n\n  const pcRef = useRef(null);\n\n  // Nettoyer la connexion\n  const cleanupPC = useCallback(() => {\n    if (pcRef.current) {\n      pcRef.current.ontrack = null;\n      pcRef.current.onicecandidate = null;\n      pcRef.current.close();\n      pcRef.current = null;\n    }\n  }, []);\n\n  // Obtenir le stream local\n  const getLocalStream = useCallback(async (type) => {\n    try {\n      const stream = await navigator.mediaDevices.getUserMedia({\n        audio: true,\n        video: type === 'video',\n      });\n      setLocalStream(stream);\n      return stream;\n    } catch (err) {\n      console.error('Erreur accès médias:', err);\n      throw err;\n    }\n  }, []);\n\n  // Créer la RTCPeerConnection\n  const createPeerConnection = useCallback((stream, remoteTargetId) => {\n    cleanupPC();\n    const pc = new RTCPeerConnection(ICE_SERVERS);\n\n    // Ajouter les tracks locaux\n    stream.getTracks().forEach((track) => pc.addTrack(track, stream));\n\n    // Préparer le stream distant\n    const remoteMediaStream = new MediaStream();\n    setRemoteStream(remoteMediaStream);\n\n    pc.ontrack = (e) => {\n      e.streams[0].getTracks().forEach((track) => {\n        remoteMediaStream.addTrack(track);\n      });\n    };\n\n    pc.onicecandidate = (e) => {\n      if (e.candidate && remoteTargetId) {\n        socket?.emit('call:ice-candidate', {\n          targetId: remoteTargetId,\n          candidate: e.candidate,\n        });\n      }\n    };\n\n    pc.onconnectionstatechange = () => {\n      if (['disconnected', 'failed', 'closed'].includes(pc.connectionState)) {\n        endCall();\n      }\n    };\n\n    pcRef.current = pc;\n    return pc;\n  }, [socket, cleanupPC]);\n\n  // ── INITIER UN APPEL ──────────────────────────────────────────────────────\n  const startCall = useCallback(async (receiverId, type = 'audio') => {\n    try {\n      setCallType(type);\n      setTargetId(receiverId);\n      setCallStatus('calling');\n\n      const stream = await getLocalStream(type);\n      const pc = createPeerConnection(stream, receiverId);\n\n      const offer = await pc.createOffer();\n      await pc.setLocalDescription(offer);\n\n      socket?.emit('call:initiate', { receiverId, callType: type, offer });\n    } catch (err) {\n      console.error('Erreur démarrage appel:', err);\n      setCallStatus('idle');\n    }\n  }, [socket, getLocalStream, createPeerConnection]);\n\n  // ── RÉPONDRE À UN APPEL ───────────────────────────────────────────────────\n  const answerCall = useCallback(async (incomingCallerId, offer, type = 'audio') => {\n    try {\n      setCallStatus('in-call');\n      setTargetId(incomingCallerId);\n\n      const stream = await getLocalStream(type);\n      const pc = createPeerConnection(stream, incomingCallerId);\n\n      await pc.setRemoteDescription(new RTCSessionDescription(offer));\n      const answer = await pc.createAnswer();\n      await pc.setLocalDescription(answer);\n\n      socket?.emit('call:answer', { callerId: incomingCallerId, answer });\n    } catch (err) {\n      console.error('Erreur réponse appel:', err);\n      setCallStatus('idle');\n    }\n  }, [socket, getLocalStream, createPeerConnection]);\n\n  // ── GÉRER LA RÉPONSE (côté appelant) ─────────────────────────────────────\n  const handleCallAnswered = useCallback(async ({ answer }) => {\n    try {\n      await pcRef.current?.setRemoteDescription(new RTCSessionDescription(answer));\n      setCallStatus('in-call');\n    } catch (err) {\n      console.error('Erreur set remote description:', err);\n    }\n  }, []);\n\n  // ── AJOUTER UN CANDIDAT ICE ───────────────────────────────────────────────\n  const handleICECandidate = useCallback(async ({ candidate }) => {\n    try {\n      await pcRef.current?.addIceCandidate(new RTCIceCandidate(candidate));\n    } catch (err) {\n      console.error('Erreur ajout ICE candidate:', err);\n    }\n  }, []);\n\n  // ── REFUSER UN APPEL ──────────────────────────────────────────────────────\n  const rejectCall = useCallback((incomingCallerId) => {\n    socket?.emit('call:reject', { callerId: incomingCallerId });\n    setCallStatus('idle');\n    setCallerId(null);\n  }, [socket]);\n\n  // ── TERMINER L'APPEL ──────────────────────────────────────────────────────\n  const endCall = useCallback((remoteTargetId = null) => {\n    const target = remoteTargetId || targetId;\n    if (target) socket?.emit('call:end', { targetId: target });\n\n    cleanupPC();\n    localStream?.getTracks().forEach((t) => t.stop());\n\n    setLocalStream(null);\n    setRemoteStream(null);\n    setCallStatus('idle');\n    setCallType(null);\n    setCallerId(null);\n    setTargetId(null);\n  }, [socket, targetId, localStream, cleanupPC]);\n\n  // ── TOGGLE MICRO/CAMÉRA ───────────────────────────────────────────────────\n  const toggleMic = useCallback(() => {\n    localStream?.getAudioTracks().forEach((t) => {\n      t.enabled = !t.enabled;\n    });\n  }, [localStream]);\n\n  const toggleCamera = useCallback(() => {\n    localStream?.getVideoTracks().forEach((t) => {\n      t.enabled = !t.enabled;\n    });\n  }, [localStream]);\n\n  return {\n    localStream, remoteStream, callStatus, callType, callerId, targetId,\n    setCallStatus, setCallType, setCallerId,\n    startCall, answerCall, rejectCall, endCall,\n    handleCallAnswered, handleICECandidate,\n    toggleMic, toggleCamera,\n  };\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}